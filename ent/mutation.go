// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/cateiru/cateiru.com/ent/biography"
	"github.com/cateiru/cateiru.com/ent/category"
	"github.com/cateiru/cateiru.com/ent/contact"
	"github.com/cateiru/cateiru.com/ent/contactdefault"
	"github.com/cateiru/cateiru.com/ent/link"
	"github.com/cateiru/cateiru.com/ent/location"
	"github.com/cateiru/cateiru.com/ent/notice"
	"github.com/cateiru/cateiru.com/ent/predicate"
	"github.com/cateiru/cateiru.com/ent/product"
	"github.com/cateiru/cateiru.com/ent/session"
	"github.com/cateiru/cateiru.com/ent/user"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBiography      = "Biography"
	TypeCategory       = "Category"
	TypeContact        = "Contact"
	TypeContactDefault = "ContactDefault"
	TypeLink           = "Link"
	TypeLocation       = "Location"
	TypeNotice         = "Notice"
	TypeProduct        = "Product"
	TypeSession        = "Session"
	TypeUser           = "User"
)

// BiographyMutation represents an operation that mutates the Biography nodes in the graph.
type BiographyMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	user_id        *uint32
	adduser_id     *int32
	is_public      *bool
	location_id    *uint32
	addlocation_id *int32
	position       *string
	position_ja    *string
	join           *time.Time
	leave          *time.Time
	created        *time.Time
	modified       *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Biography, error)
	predicates     []predicate.Biography
}

var _ ent.Mutation = (*BiographyMutation)(nil)

// biographyOption allows management of the mutation configuration using functional options.
type biographyOption func(*BiographyMutation)

// newBiographyMutation creates new mutation for the Biography entity.
func newBiographyMutation(c config, op Op, opts ...biographyOption) *BiographyMutation {
	m := &BiographyMutation{
		config:        c,
		op:            op,
		typ:           TypeBiography,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBiographyID sets the ID field of the mutation.
func withBiographyID(id uint32) biographyOption {
	return func(m *BiographyMutation) {
		var (
			err   error
			once  sync.Once
			value *Biography
		)
		m.oldValue = func(ctx context.Context) (*Biography, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Biography.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBiography sets the old Biography of the mutation.
func withBiography(node *Biography) biographyOption {
	return func(m *BiographyMutation) {
		m.oldValue = func(context.Context) (*Biography, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BiographyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BiographyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Biography entities.
func (m *BiographyMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BiographyMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BiographyMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Biography.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *BiographyMutation) SetUserID(u uint32) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *BiographyMutation) UserID() (r uint32, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Biography entity.
// If the Biography object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BiographyMutation) OldUserID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *BiographyMutation) AddUserID(u int32) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *BiographyMutation) AddedUserID() (r int32, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *BiographyMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetIsPublic sets the "is_public" field.
func (m *BiographyMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the value of the "is_public" field in the mutation.
func (m *BiographyMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "is_public" field's value of the Biography entity.
// If the Biography object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BiographyMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "is_public" field.
func (m *BiographyMutation) ResetIsPublic() {
	m.is_public = nil
}

// SetLocationID sets the "location_id" field.
func (m *BiographyMutation) SetLocationID(u uint32) {
	m.location_id = &u
	m.addlocation_id = nil
}

// LocationID returns the value of the "location_id" field in the mutation.
func (m *BiographyMutation) LocationID() (r uint32, exists bool) {
	v := m.location_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationID returns the old "location_id" field's value of the Biography entity.
// If the Biography object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BiographyMutation) OldLocationID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationID: %w", err)
	}
	return oldValue.LocationID, nil
}

// AddLocationID adds u to the "location_id" field.
func (m *BiographyMutation) AddLocationID(u int32) {
	if m.addlocation_id != nil {
		*m.addlocation_id += u
	} else {
		m.addlocation_id = &u
	}
}

// AddedLocationID returns the value that was added to the "location_id" field in this mutation.
func (m *BiographyMutation) AddedLocationID() (r int32, exists bool) {
	v := m.addlocation_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetLocationID resets all changes to the "location_id" field.
func (m *BiographyMutation) ResetLocationID() {
	m.location_id = nil
	m.addlocation_id = nil
}

// SetPosition sets the "position" field.
func (m *BiographyMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the value of the "position" field in the mutation.
func (m *BiographyMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the Biography entity.
// If the Biography object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BiographyMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ResetPosition resets all changes to the "position" field.
func (m *BiographyMutation) ResetPosition() {
	m.position = nil
}

// SetPositionJa sets the "position_ja" field.
func (m *BiographyMutation) SetPositionJa(s string) {
	m.position_ja = &s
}

// PositionJa returns the value of the "position_ja" field in the mutation.
func (m *BiographyMutation) PositionJa() (r string, exists bool) {
	v := m.position_ja
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionJa returns the old "position_ja" field's value of the Biography entity.
// If the Biography object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BiographyMutation) OldPositionJa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPositionJa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPositionJa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionJa: %w", err)
	}
	return oldValue.PositionJa, nil
}

// ResetPositionJa resets all changes to the "position_ja" field.
func (m *BiographyMutation) ResetPositionJa() {
	m.position_ja = nil
}

// SetJoin sets the "join" field.
func (m *BiographyMutation) SetJoin(t time.Time) {
	m.join = &t
}

// Join returns the value of the "join" field in the mutation.
func (m *BiographyMutation) Join() (r time.Time, exists bool) {
	v := m.join
	if v == nil {
		return
	}
	return *v, true
}

// OldJoin returns the old "join" field's value of the Biography entity.
// If the Biography object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BiographyMutation) OldJoin(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoin: %w", err)
	}
	return oldValue.Join, nil
}

// ResetJoin resets all changes to the "join" field.
func (m *BiographyMutation) ResetJoin() {
	m.join = nil
}

// SetLeave sets the "leave" field.
func (m *BiographyMutation) SetLeave(t time.Time) {
	m.leave = &t
}

// Leave returns the value of the "leave" field in the mutation.
func (m *BiographyMutation) Leave() (r time.Time, exists bool) {
	v := m.leave
	if v == nil {
		return
	}
	return *v, true
}

// OldLeave returns the old "leave" field's value of the Biography entity.
// If the Biography object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BiographyMutation) OldLeave(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeave is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeave requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeave: %w", err)
	}
	return oldValue.Leave, nil
}

// ClearLeave clears the value of the "leave" field.
func (m *BiographyMutation) ClearLeave() {
	m.leave = nil
	m.clearedFields[biography.FieldLeave] = struct{}{}
}

// LeaveCleared returns if the "leave" field was cleared in this mutation.
func (m *BiographyMutation) LeaveCleared() bool {
	_, ok := m.clearedFields[biography.FieldLeave]
	return ok
}

// ResetLeave resets all changes to the "leave" field.
func (m *BiographyMutation) ResetLeave() {
	m.leave = nil
	delete(m.clearedFields, biography.FieldLeave)
}

// SetCreated sets the "created" field.
func (m *BiographyMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *BiographyMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the Biography entity.
// If the Biography object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BiographyMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ResetCreated resets all changes to the "created" field.
func (m *BiographyMutation) ResetCreated() {
	m.created = nil
}

// SetModified sets the "modified" field.
func (m *BiographyMutation) SetModified(t time.Time) {
	m.modified = &t
}

// Modified returns the value of the "modified" field in the mutation.
func (m *BiographyMutation) Modified() (r time.Time, exists bool) {
	v := m.modified
	if v == nil {
		return
	}
	return *v, true
}

// OldModified returns the old "modified" field's value of the Biography entity.
// If the Biography object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BiographyMutation) OldModified(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModified: %w", err)
	}
	return oldValue.Modified, nil
}

// ResetModified resets all changes to the "modified" field.
func (m *BiographyMutation) ResetModified() {
	m.modified = nil
}

// Where appends a list predicates to the BiographyMutation builder.
func (m *BiographyMutation) Where(ps ...predicate.Biography) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BiographyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BiographyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Biography, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BiographyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BiographyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Biography).
func (m *BiographyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BiographyMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.user_id != nil {
		fields = append(fields, biography.FieldUserID)
	}
	if m.is_public != nil {
		fields = append(fields, biography.FieldIsPublic)
	}
	if m.location_id != nil {
		fields = append(fields, biography.FieldLocationID)
	}
	if m.position != nil {
		fields = append(fields, biography.FieldPosition)
	}
	if m.position_ja != nil {
		fields = append(fields, biography.FieldPositionJa)
	}
	if m.join != nil {
		fields = append(fields, biography.FieldJoin)
	}
	if m.leave != nil {
		fields = append(fields, biography.FieldLeave)
	}
	if m.created != nil {
		fields = append(fields, biography.FieldCreated)
	}
	if m.modified != nil {
		fields = append(fields, biography.FieldModified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BiographyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case biography.FieldUserID:
		return m.UserID()
	case biography.FieldIsPublic:
		return m.IsPublic()
	case biography.FieldLocationID:
		return m.LocationID()
	case biography.FieldPosition:
		return m.Position()
	case biography.FieldPositionJa:
		return m.PositionJa()
	case biography.FieldJoin:
		return m.Join()
	case biography.FieldLeave:
		return m.Leave()
	case biography.FieldCreated:
		return m.Created()
	case biography.FieldModified:
		return m.Modified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BiographyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case biography.FieldUserID:
		return m.OldUserID(ctx)
	case biography.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case biography.FieldLocationID:
		return m.OldLocationID(ctx)
	case biography.FieldPosition:
		return m.OldPosition(ctx)
	case biography.FieldPositionJa:
		return m.OldPositionJa(ctx)
	case biography.FieldJoin:
		return m.OldJoin(ctx)
	case biography.FieldLeave:
		return m.OldLeave(ctx)
	case biography.FieldCreated:
		return m.OldCreated(ctx)
	case biography.FieldModified:
		return m.OldModified(ctx)
	}
	return nil, fmt.Errorf("unknown Biography field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BiographyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case biography.FieldUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case biography.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case biography.FieldLocationID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationID(v)
		return nil
	case biography.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case biography.FieldPositionJa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionJa(v)
		return nil
	case biography.FieldJoin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoin(v)
		return nil
	case biography.FieldLeave:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeave(v)
		return nil
	case biography.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case biography.FieldModified:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModified(v)
		return nil
	}
	return fmt.Errorf("unknown Biography field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BiographyMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, biography.FieldUserID)
	}
	if m.addlocation_id != nil {
		fields = append(fields, biography.FieldLocationID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BiographyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case biography.FieldUserID:
		return m.AddedUserID()
	case biography.FieldLocationID:
		return m.AddedLocationID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BiographyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case biography.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case biography.FieldLocationID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLocationID(v)
		return nil
	}
	return fmt.Errorf("unknown Biography numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BiographyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(biography.FieldLeave) {
		fields = append(fields, biography.FieldLeave)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BiographyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BiographyMutation) ClearField(name string) error {
	switch name {
	case biography.FieldLeave:
		m.ClearLeave()
		return nil
	}
	return fmt.Errorf("unknown Biography nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BiographyMutation) ResetField(name string) error {
	switch name {
	case biography.FieldUserID:
		m.ResetUserID()
		return nil
	case biography.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case biography.FieldLocationID:
		m.ResetLocationID()
		return nil
	case biography.FieldPosition:
		m.ResetPosition()
		return nil
	case biography.FieldPositionJa:
		m.ResetPositionJa()
		return nil
	case biography.FieldJoin:
		m.ResetJoin()
		return nil
	case biography.FieldLeave:
		m.ResetLeave()
		return nil
	case biography.FieldCreated:
		m.ResetCreated()
		return nil
	case biography.FieldModified:
		m.ResetModified()
		return nil
	}
	return fmt.Errorf("unknown Biography field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BiographyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BiographyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BiographyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BiographyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BiographyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BiographyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BiographyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Biography unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BiographyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Biography edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	name          *string
	name_ja       *string
	emoji         *string
	created       *time.Time
	modified      *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Category, error)
	predicates    []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id uint32) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Category entities.
func (m *CategoryMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetNameJa sets the "name_ja" field.
func (m *CategoryMutation) SetNameJa(s string) {
	m.name_ja = &s
}

// NameJa returns the value of the "name_ja" field in the mutation.
func (m *CategoryMutation) NameJa() (r string, exists bool) {
	v := m.name_ja
	if v == nil {
		return
	}
	return *v, true
}

// OldNameJa returns the old "name_ja" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldNameJa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameJa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameJa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameJa: %w", err)
	}
	return oldValue.NameJa, nil
}

// ResetNameJa resets all changes to the "name_ja" field.
func (m *CategoryMutation) ResetNameJa() {
	m.name_ja = nil
}

// SetEmoji sets the "emoji" field.
func (m *CategoryMutation) SetEmoji(s string) {
	m.emoji = &s
}

// Emoji returns the value of the "emoji" field in the mutation.
func (m *CategoryMutation) Emoji() (r string, exists bool) {
	v := m.emoji
	if v == nil {
		return
	}
	return *v, true
}

// OldEmoji returns the old "emoji" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldEmoji(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmoji is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmoji requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmoji: %w", err)
	}
	return oldValue.Emoji, nil
}

// ResetEmoji resets all changes to the "emoji" field.
func (m *CategoryMutation) ResetEmoji() {
	m.emoji = nil
}

// SetCreated sets the "created" field.
func (m *CategoryMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *CategoryMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ResetCreated resets all changes to the "created" field.
func (m *CategoryMutation) ResetCreated() {
	m.created = nil
}

// SetModified sets the "modified" field.
func (m *CategoryMutation) SetModified(t time.Time) {
	m.modified = &t
}

// Modified returns the value of the "modified" field in the mutation.
func (m *CategoryMutation) Modified() (r time.Time, exists bool) {
	v := m.modified
	if v == nil {
		return
	}
	return *v, true
}

// OldModified returns the old "modified" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldModified(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModified: %w", err)
	}
	return oldValue.Modified, nil
}

// ResetModified resets all changes to the "modified" field.
func (m *CategoryMutation) ResetModified() {
	m.modified = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.name_ja != nil {
		fields = append(fields, category.FieldNameJa)
	}
	if m.emoji != nil {
		fields = append(fields, category.FieldEmoji)
	}
	if m.created != nil {
		fields = append(fields, category.FieldCreated)
	}
	if m.modified != nil {
		fields = append(fields, category.FieldModified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldName:
		return m.Name()
	case category.FieldNameJa:
		return m.NameJa()
	case category.FieldEmoji:
		return m.Emoji()
	case category.FieldCreated:
		return m.Created()
	case category.FieldModified:
		return m.Modified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldNameJa:
		return m.OldNameJa(ctx)
	case category.FieldEmoji:
		return m.OldEmoji(ctx)
	case category.FieldCreated:
		return m.OldCreated(ctx)
	case category.FieldModified:
		return m.OldModified(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldNameJa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameJa(v)
		return nil
	case category.FieldEmoji:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmoji(v)
		return nil
	case category.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case category.FieldModified:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModified(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldNameJa:
		m.ResetNameJa()
		return nil
	case category.FieldEmoji:
		m.ResetEmoji()
		return nil
	case category.FieldCreated:
		m.ResetCreated()
		return nil
	case category.FieldModified:
		m.ResetModified()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Category edge %s", name)
}

// ContactMutation represents an operation that mutates the Contact nodes in the graph.
type ContactMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	to_user_id    *uint32
	addto_user_id *int32
	name          *string
	title         *string
	detail        *string
	mail          *string
	ip            *string
	lang          *string
	url           *string
	category      *string
	custom_title  *string
	custom_value  *string
	device_name   *string
	os            *string
	browser_name  *string
	is_mobile     *bool
	created       *time.Time
	modified      *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Contact, error)
	predicates    []predicate.Contact
}

var _ ent.Mutation = (*ContactMutation)(nil)

// contactOption allows management of the mutation configuration using functional options.
type contactOption func(*ContactMutation)

// newContactMutation creates new mutation for the Contact entity.
func newContactMutation(c config, op Op, opts ...contactOption) *ContactMutation {
	m := &ContactMutation{
		config:        c,
		op:            op,
		typ:           TypeContact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContactID sets the ID field of the mutation.
func withContactID(id uint32) contactOption {
	return func(m *ContactMutation) {
		var (
			err   error
			once  sync.Once
			value *Contact
		)
		m.oldValue = func(ctx context.Context) (*Contact, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Contact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContact sets the old Contact of the mutation.
func withContact(node *Contact) contactOption {
	return func(m *ContactMutation) {
		m.oldValue = func(context.Context) (*Contact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Contact entities.
func (m *ContactMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContactMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContactMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Contact.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetToUserID sets the "to_user_id" field.
func (m *ContactMutation) SetToUserID(u uint32) {
	m.to_user_id = &u
	m.addto_user_id = nil
}

// ToUserID returns the value of the "to_user_id" field in the mutation.
func (m *ContactMutation) ToUserID() (r uint32, exists bool) {
	v := m.to_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldToUserID returns the old "to_user_id" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldToUserID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToUserID: %w", err)
	}
	return oldValue.ToUserID, nil
}

// AddToUserID adds u to the "to_user_id" field.
func (m *ContactMutation) AddToUserID(u int32) {
	if m.addto_user_id != nil {
		*m.addto_user_id += u
	} else {
		m.addto_user_id = &u
	}
}

// AddedToUserID returns the value that was added to the "to_user_id" field in this mutation.
func (m *ContactMutation) AddedToUserID() (r int32, exists bool) {
	v := m.addto_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetToUserID resets all changes to the "to_user_id" field.
func (m *ContactMutation) ResetToUserID() {
	m.to_user_id = nil
	m.addto_user_id = nil
}

// SetName sets the "name" field.
func (m *ContactMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ContactMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ContactMutation) ResetName() {
	m.name = nil
}

// SetTitle sets the "title" field.
func (m *ContactMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ContactMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ContactMutation) ResetTitle() {
	m.title = nil
}

// SetDetail sets the "detail" field.
func (m *ContactMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *ContactMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ResetDetail resets all changes to the "detail" field.
func (m *ContactMutation) ResetDetail() {
	m.detail = nil
}

// SetMail sets the "mail" field.
func (m *ContactMutation) SetMail(s string) {
	m.mail = &s
}

// Mail returns the value of the "mail" field in the mutation.
func (m *ContactMutation) Mail() (r string, exists bool) {
	v := m.mail
	if v == nil {
		return
	}
	return *v, true
}

// OldMail returns the old "mail" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldMail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMail: %w", err)
	}
	return oldValue.Mail, nil
}

// ResetMail resets all changes to the "mail" field.
func (m *ContactMutation) ResetMail() {
	m.mail = nil
}

// SetIP sets the "ip" field.
func (m *ContactMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *ContactMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *ContactMutation) ResetIP() {
	m.ip = nil
}

// SetLang sets the "lang" field.
func (m *ContactMutation) SetLang(s string) {
	m.lang = &s
}

// Lang returns the value of the "lang" field in the mutation.
func (m *ContactMutation) Lang() (r string, exists bool) {
	v := m.lang
	if v == nil {
		return
	}
	return *v, true
}

// OldLang returns the old "lang" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldLang(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLang is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLang requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLang: %w", err)
	}
	return oldValue.Lang, nil
}

// ResetLang resets all changes to the "lang" field.
func (m *ContactMutation) ResetLang() {
	m.lang = nil
}

// SetURL sets the "url" field.
func (m *ContactMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ContactMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *ContactMutation) ClearURL() {
	m.url = nil
	m.clearedFields[contact.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *ContactMutation) URLCleared() bool {
	_, ok := m.clearedFields[contact.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *ContactMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, contact.FieldURL)
}

// SetCategory sets the "category" field.
func (m *ContactMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ContactMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *ContactMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[contact.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *ContactMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[contact.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *ContactMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, contact.FieldCategory)
}

// SetCustomTitle sets the "custom_title" field.
func (m *ContactMutation) SetCustomTitle(s string) {
	m.custom_title = &s
}

// CustomTitle returns the value of the "custom_title" field in the mutation.
func (m *ContactMutation) CustomTitle() (r string, exists bool) {
	v := m.custom_title
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomTitle returns the old "custom_title" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldCustomTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomTitle: %w", err)
	}
	return oldValue.CustomTitle, nil
}

// ClearCustomTitle clears the value of the "custom_title" field.
func (m *ContactMutation) ClearCustomTitle() {
	m.custom_title = nil
	m.clearedFields[contact.FieldCustomTitle] = struct{}{}
}

// CustomTitleCleared returns if the "custom_title" field was cleared in this mutation.
func (m *ContactMutation) CustomTitleCleared() bool {
	_, ok := m.clearedFields[contact.FieldCustomTitle]
	return ok
}

// ResetCustomTitle resets all changes to the "custom_title" field.
func (m *ContactMutation) ResetCustomTitle() {
	m.custom_title = nil
	delete(m.clearedFields, contact.FieldCustomTitle)
}

// SetCustomValue sets the "custom_value" field.
func (m *ContactMutation) SetCustomValue(s string) {
	m.custom_value = &s
}

// CustomValue returns the value of the "custom_value" field in the mutation.
func (m *ContactMutation) CustomValue() (r string, exists bool) {
	v := m.custom_value
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomValue returns the old "custom_value" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldCustomValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomValue: %w", err)
	}
	return oldValue.CustomValue, nil
}

// ClearCustomValue clears the value of the "custom_value" field.
func (m *ContactMutation) ClearCustomValue() {
	m.custom_value = nil
	m.clearedFields[contact.FieldCustomValue] = struct{}{}
}

// CustomValueCleared returns if the "custom_value" field was cleared in this mutation.
func (m *ContactMutation) CustomValueCleared() bool {
	_, ok := m.clearedFields[contact.FieldCustomValue]
	return ok
}

// ResetCustomValue resets all changes to the "custom_value" field.
func (m *ContactMutation) ResetCustomValue() {
	m.custom_value = nil
	delete(m.clearedFields, contact.FieldCustomValue)
}

// SetDeviceName sets the "device_name" field.
func (m *ContactMutation) SetDeviceName(s string) {
	m.device_name = &s
}

// DeviceName returns the value of the "device_name" field in the mutation.
func (m *ContactMutation) DeviceName() (r string, exists bool) {
	v := m.device_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceName returns the old "device_name" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldDeviceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceName: %w", err)
	}
	return oldValue.DeviceName, nil
}

// ClearDeviceName clears the value of the "device_name" field.
func (m *ContactMutation) ClearDeviceName() {
	m.device_name = nil
	m.clearedFields[contact.FieldDeviceName] = struct{}{}
}

// DeviceNameCleared returns if the "device_name" field was cleared in this mutation.
func (m *ContactMutation) DeviceNameCleared() bool {
	_, ok := m.clearedFields[contact.FieldDeviceName]
	return ok
}

// ResetDeviceName resets all changes to the "device_name" field.
func (m *ContactMutation) ResetDeviceName() {
	m.device_name = nil
	delete(m.clearedFields, contact.FieldDeviceName)
}

// SetOs sets the "os" field.
func (m *ContactMutation) SetOs(s string) {
	m.os = &s
}

// Os returns the value of the "os" field in the mutation.
func (m *ContactMutation) Os() (r string, exists bool) {
	v := m.os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "os" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldOs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ClearOs clears the value of the "os" field.
func (m *ContactMutation) ClearOs() {
	m.os = nil
	m.clearedFields[contact.FieldOs] = struct{}{}
}

// OsCleared returns if the "os" field was cleared in this mutation.
func (m *ContactMutation) OsCleared() bool {
	_, ok := m.clearedFields[contact.FieldOs]
	return ok
}

// ResetOs resets all changes to the "os" field.
func (m *ContactMutation) ResetOs() {
	m.os = nil
	delete(m.clearedFields, contact.FieldOs)
}

// SetBrowserName sets the "browser_name" field.
func (m *ContactMutation) SetBrowserName(s string) {
	m.browser_name = &s
}

// BrowserName returns the value of the "browser_name" field in the mutation.
func (m *ContactMutation) BrowserName() (r string, exists bool) {
	v := m.browser_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBrowserName returns the old "browser_name" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldBrowserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrowserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrowserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrowserName: %w", err)
	}
	return oldValue.BrowserName, nil
}

// ClearBrowserName clears the value of the "browser_name" field.
func (m *ContactMutation) ClearBrowserName() {
	m.browser_name = nil
	m.clearedFields[contact.FieldBrowserName] = struct{}{}
}

// BrowserNameCleared returns if the "browser_name" field was cleared in this mutation.
func (m *ContactMutation) BrowserNameCleared() bool {
	_, ok := m.clearedFields[contact.FieldBrowserName]
	return ok
}

// ResetBrowserName resets all changes to the "browser_name" field.
func (m *ContactMutation) ResetBrowserName() {
	m.browser_name = nil
	delete(m.clearedFields, contact.FieldBrowserName)
}

// SetIsMobile sets the "is_mobile" field.
func (m *ContactMutation) SetIsMobile(b bool) {
	m.is_mobile = &b
}

// IsMobile returns the value of the "is_mobile" field in the mutation.
func (m *ContactMutation) IsMobile() (r bool, exists bool) {
	v := m.is_mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldIsMobile returns the old "is_mobile" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldIsMobile(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsMobile: %w", err)
	}
	return oldValue.IsMobile, nil
}

// ClearIsMobile clears the value of the "is_mobile" field.
func (m *ContactMutation) ClearIsMobile() {
	m.is_mobile = nil
	m.clearedFields[contact.FieldIsMobile] = struct{}{}
}

// IsMobileCleared returns if the "is_mobile" field was cleared in this mutation.
func (m *ContactMutation) IsMobileCleared() bool {
	_, ok := m.clearedFields[contact.FieldIsMobile]
	return ok
}

// ResetIsMobile resets all changes to the "is_mobile" field.
func (m *ContactMutation) ResetIsMobile() {
	m.is_mobile = nil
	delete(m.clearedFields, contact.FieldIsMobile)
}

// SetCreated sets the "created" field.
func (m *ContactMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *ContactMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ResetCreated resets all changes to the "created" field.
func (m *ContactMutation) ResetCreated() {
	m.created = nil
}

// SetModified sets the "modified" field.
func (m *ContactMutation) SetModified(t time.Time) {
	m.modified = &t
}

// Modified returns the value of the "modified" field in the mutation.
func (m *ContactMutation) Modified() (r time.Time, exists bool) {
	v := m.modified
	if v == nil {
		return
	}
	return *v, true
}

// OldModified returns the old "modified" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldModified(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModified: %w", err)
	}
	return oldValue.Modified, nil
}

// ResetModified resets all changes to the "modified" field.
func (m *ContactMutation) ResetModified() {
	m.modified = nil
}

// Where appends a list predicates to the ContactMutation builder.
func (m *ContactMutation) Where(ps ...predicate.Contact) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContactMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContactMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Contact, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContactMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContactMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Contact).
func (m *ContactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContactMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.to_user_id != nil {
		fields = append(fields, contact.FieldToUserID)
	}
	if m.name != nil {
		fields = append(fields, contact.FieldName)
	}
	if m.title != nil {
		fields = append(fields, contact.FieldTitle)
	}
	if m.detail != nil {
		fields = append(fields, contact.FieldDetail)
	}
	if m.mail != nil {
		fields = append(fields, contact.FieldMail)
	}
	if m.ip != nil {
		fields = append(fields, contact.FieldIP)
	}
	if m.lang != nil {
		fields = append(fields, contact.FieldLang)
	}
	if m.url != nil {
		fields = append(fields, contact.FieldURL)
	}
	if m.category != nil {
		fields = append(fields, contact.FieldCategory)
	}
	if m.custom_title != nil {
		fields = append(fields, contact.FieldCustomTitle)
	}
	if m.custom_value != nil {
		fields = append(fields, contact.FieldCustomValue)
	}
	if m.device_name != nil {
		fields = append(fields, contact.FieldDeviceName)
	}
	if m.os != nil {
		fields = append(fields, contact.FieldOs)
	}
	if m.browser_name != nil {
		fields = append(fields, contact.FieldBrowserName)
	}
	if m.is_mobile != nil {
		fields = append(fields, contact.FieldIsMobile)
	}
	if m.created != nil {
		fields = append(fields, contact.FieldCreated)
	}
	if m.modified != nil {
		fields = append(fields, contact.FieldModified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contact.FieldToUserID:
		return m.ToUserID()
	case contact.FieldName:
		return m.Name()
	case contact.FieldTitle:
		return m.Title()
	case contact.FieldDetail:
		return m.Detail()
	case contact.FieldMail:
		return m.Mail()
	case contact.FieldIP:
		return m.IP()
	case contact.FieldLang:
		return m.Lang()
	case contact.FieldURL:
		return m.URL()
	case contact.FieldCategory:
		return m.Category()
	case contact.FieldCustomTitle:
		return m.CustomTitle()
	case contact.FieldCustomValue:
		return m.CustomValue()
	case contact.FieldDeviceName:
		return m.DeviceName()
	case contact.FieldOs:
		return m.Os()
	case contact.FieldBrowserName:
		return m.BrowserName()
	case contact.FieldIsMobile:
		return m.IsMobile()
	case contact.FieldCreated:
		return m.Created()
	case contact.FieldModified:
		return m.Modified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contact.FieldToUserID:
		return m.OldToUserID(ctx)
	case contact.FieldName:
		return m.OldName(ctx)
	case contact.FieldTitle:
		return m.OldTitle(ctx)
	case contact.FieldDetail:
		return m.OldDetail(ctx)
	case contact.FieldMail:
		return m.OldMail(ctx)
	case contact.FieldIP:
		return m.OldIP(ctx)
	case contact.FieldLang:
		return m.OldLang(ctx)
	case contact.FieldURL:
		return m.OldURL(ctx)
	case contact.FieldCategory:
		return m.OldCategory(ctx)
	case contact.FieldCustomTitle:
		return m.OldCustomTitle(ctx)
	case contact.FieldCustomValue:
		return m.OldCustomValue(ctx)
	case contact.FieldDeviceName:
		return m.OldDeviceName(ctx)
	case contact.FieldOs:
		return m.OldOs(ctx)
	case contact.FieldBrowserName:
		return m.OldBrowserName(ctx)
	case contact.FieldIsMobile:
		return m.OldIsMobile(ctx)
	case contact.FieldCreated:
		return m.OldCreated(ctx)
	case contact.FieldModified:
		return m.OldModified(ctx)
	}
	return nil, fmt.Errorf("unknown Contact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contact.FieldToUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToUserID(v)
		return nil
	case contact.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case contact.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case contact.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case contact.FieldMail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMail(v)
		return nil
	case contact.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case contact.FieldLang:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLang(v)
		return nil
	case contact.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case contact.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case contact.FieldCustomTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomTitle(v)
		return nil
	case contact.FieldCustomValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomValue(v)
		return nil
	case contact.FieldDeviceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceName(v)
		return nil
	case contact.FieldOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case contact.FieldBrowserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrowserName(v)
		return nil
	case contact.FieldIsMobile:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsMobile(v)
		return nil
	case contact.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case contact.FieldModified:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModified(v)
		return nil
	}
	return fmt.Errorf("unknown Contact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContactMutation) AddedFields() []string {
	var fields []string
	if m.addto_user_id != nil {
		fields = append(fields, contact.FieldToUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContactMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contact.FieldToUserID:
		return m.AddedToUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contact.FieldToUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddToUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Contact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContactMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contact.FieldURL) {
		fields = append(fields, contact.FieldURL)
	}
	if m.FieldCleared(contact.FieldCategory) {
		fields = append(fields, contact.FieldCategory)
	}
	if m.FieldCleared(contact.FieldCustomTitle) {
		fields = append(fields, contact.FieldCustomTitle)
	}
	if m.FieldCleared(contact.FieldCustomValue) {
		fields = append(fields, contact.FieldCustomValue)
	}
	if m.FieldCleared(contact.FieldDeviceName) {
		fields = append(fields, contact.FieldDeviceName)
	}
	if m.FieldCleared(contact.FieldOs) {
		fields = append(fields, contact.FieldOs)
	}
	if m.FieldCleared(contact.FieldBrowserName) {
		fields = append(fields, contact.FieldBrowserName)
	}
	if m.FieldCleared(contact.FieldIsMobile) {
		fields = append(fields, contact.FieldIsMobile)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContactMutation) ClearField(name string) error {
	switch name {
	case contact.FieldURL:
		m.ClearURL()
		return nil
	case contact.FieldCategory:
		m.ClearCategory()
		return nil
	case contact.FieldCustomTitle:
		m.ClearCustomTitle()
		return nil
	case contact.FieldCustomValue:
		m.ClearCustomValue()
		return nil
	case contact.FieldDeviceName:
		m.ClearDeviceName()
		return nil
	case contact.FieldOs:
		m.ClearOs()
		return nil
	case contact.FieldBrowserName:
		m.ClearBrowserName()
		return nil
	case contact.FieldIsMobile:
		m.ClearIsMobile()
		return nil
	}
	return fmt.Errorf("unknown Contact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContactMutation) ResetField(name string) error {
	switch name {
	case contact.FieldToUserID:
		m.ResetToUserID()
		return nil
	case contact.FieldName:
		m.ResetName()
		return nil
	case contact.FieldTitle:
		m.ResetTitle()
		return nil
	case contact.FieldDetail:
		m.ResetDetail()
		return nil
	case contact.FieldMail:
		m.ResetMail()
		return nil
	case contact.FieldIP:
		m.ResetIP()
		return nil
	case contact.FieldLang:
		m.ResetLang()
		return nil
	case contact.FieldURL:
		m.ResetURL()
		return nil
	case contact.FieldCategory:
		m.ResetCategory()
		return nil
	case contact.FieldCustomTitle:
		m.ResetCustomTitle()
		return nil
	case contact.FieldCustomValue:
		m.ResetCustomValue()
		return nil
	case contact.FieldDeviceName:
		m.ResetDeviceName()
		return nil
	case contact.FieldOs:
		m.ResetOs()
		return nil
	case contact.FieldBrowserName:
		m.ResetBrowserName()
		return nil
	case contact.FieldIsMobile:
		m.ResetIsMobile()
		return nil
	case contact.FieldCreated:
		m.ResetCreated()
		return nil
	case contact.FieldModified:
		m.ResetModified()
		return nil
	}
	return fmt.Errorf("unknown Contact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContactMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContactMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContactMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContactMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContactMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Contact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContactMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Contact edge %s", name)
}

// ContactDefaultMutation represents an operation that mutates the ContactDefault nodes in the graph.
type ContactDefaultMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	name          *string
	email         *string
	url           *string
	category      *string
	custom_title  *string
	description   *string
	created       *time.Time
	modified      *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ContactDefault, error)
	predicates    []predicate.ContactDefault
}

var _ ent.Mutation = (*ContactDefaultMutation)(nil)

// contactdefaultOption allows management of the mutation configuration using functional options.
type contactdefaultOption func(*ContactDefaultMutation)

// newContactDefaultMutation creates new mutation for the ContactDefault entity.
func newContactDefaultMutation(c config, op Op, opts ...contactdefaultOption) *ContactDefaultMutation {
	m := &ContactDefaultMutation{
		config:        c,
		op:            op,
		typ:           TypeContactDefault,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContactDefaultID sets the ID field of the mutation.
func withContactDefaultID(id uint32) contactdefaultOption {
	return func(m *ContactDefaultMutation) {
		var (
			err   error
			once  sync.Once
			value *ContactDefault
		)
		m.oldValue = func(ctx context.Context) (*ContactDefault, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ContactDefault.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContactDefault sets the old ContactDefault of the mutation.
func withContactDefault(node *ContactDefault) contactdefaultOption {
	return func(m *ContactDefaultMutation) {
		m.oldValue = func(context.Context) (*ContactDefault, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContactDefaultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContactDefaultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ContactDefault entities.
func (m *ContactDefaultMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContactDefaultMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContactDefaultMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ContactDefault.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ContactDefaultMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ContactDefaultMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ContactDefault entity.
// If the ContactDefault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactDefaultMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ContactDefaultMutation) ClearName() {
	m.name = nil
	m.clearedFields[contactdefault.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ContactDefaultMutation) NameCleared() bool {
	_, ok := m.clearedFields[contactdefault.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ContactDefaultMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, contactdefault.FieldName)
}

// SetEmail sets the "email" field.
func (m *ContactDefaultMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *ContactDefaultMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the ContactDefault entity.
// If the ContactDefault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactDefaultMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *ContactDefaultMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[contactdefault.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *ContactDefaultMutation) EmailCleared() bool {
	_, ok := m.clearedFields[contactdefault.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *ContactDefaultMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, contactdefault.FieldEmail)
}

// SetURL sets the "url" field.
func (m *ContactDefaultMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ContactDefaultMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the ContactDefault entity.
// If the ContactDefault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactDefaultMutation) OldURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *ContactDefaultMutation) ClearURL() {
	m.url = nil
	m.clearedFields[contactdefault.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *ContactDefaultMutation) URLCleared() bool {
	_, ok := m.clearedFields[contactdefault.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *ContactDefaultMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, contactdefault.FieldURL)
}

// SetCategory sets the "category" field.
func (m *ContactDefaultMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ContactDefaultMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the ContactDefault entity.
// If the ContactDefault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactDefaultMutation) OldCategory(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *ContactDefaultMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[contactdefault.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *ContactDefaultMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[contactdefault.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *ContactDefaultMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, contactdefault.FieldCategory)
}

// SetCustomTitle sets the "custom_title" field.
func (m *ContactDefaultMutation) SetCustomTitle(s string) {
	m.custom_title = &s
}

// CustomTitle returns the value of the "custom_title" field in the mutation.
func (m *ContactDefaultMutation) CustomTitle() (r string, exists bool) {
	v := m.custom_title
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomTitle returns the old "custom_title" field's value of the ContactDefault entity.
// If the ContactDefault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactDefaultMutation) OldCustomTitle(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomTitle: %w", err)
	}
	return oldValue.CustomTitle, nil
}

// ClearCustomTitle clears the value of the "custom_title" field.
func (m *ContactDefaultMutation) ClearCustomTitle() {
	m.custom_title = nil
	m.clearedFields[contactdefault.FieldCustomTitle] = struct{}{}
}

// CustomTitleCleared returns if the "custom_title" field was cleared in this mutation.
func (m *ContactDefaultMutation) CustomTitleCleared() bool {
	_, ok := m.clearedFields[contactdefault.FieldCustomTitle]
	return ok
}

// ResetCustomTitle resets all changes to the "custom_title" field.
func (m *ContactDefaultMutation) ResetCustomTitle() {
	m.custom_title = nil
	delete(m.clearedFields, contactdefault.FieldCustomTitle)
}

// SetDescription sets the "description" field.
func (m *ContactDefaultMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ContactDefaultMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ContactDefault entity.
// If the ContactDefault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactDefaultMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ContactDefaultMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[contactdefault.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ContactDefaultMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[contactdefault.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ContactDefaultMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, contactdefault.FieldDescription)
}

// SetCreated sets the "created" field.
func (m *ContactDefaultMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *ContactDefaultMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the ContactDefault entity.
// If the ContactDefault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactDefaultMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ResetCreated resets all changes to the "created" field.
func (m *ContactDefaultMutation) ResetCreated() {
	m.created = nil
}

// SetModified sets the "modified" field.
func (m *ContactDefaultMutation) SetModified(t time.Time) {
	m.modified = &t
}

// Modified returns the value of the "modified" field in the mutation.
func (m *ContactDefaultMutation) Modified() (r time.Time, exists bool) {
	v := m.modified
	if v == nil {
		return
	}
	return *v, true
}

// OldModified returns the old "modified" field's value of the ContactDefault entity.
// If the ContactDefault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactDefaultMutation) OldModified(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModified: %w", err)
	}
	return oldValue.Modified, nil
}

// ResetModified resets all changes to the "modified" field.
func (m *ContactDefaultMutation) ResetModified() {
	m.modified = nil
}

// Where appends a list predicates to the ContactDefaultMutation builder.
func (m *ContactDefaultMutation) Where(ps ...predicate.ContactDefault) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContactDefaultMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContactDefaultMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ContactDefault, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContactDefaultMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContactDefaultMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ContactDefault).
func (m *ContactDefaultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContactDefaultMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, contactdefault.FieldName)
	}
	if m.email != nil {
		fields = append(fields, contactdefault.FieldEmail)
	}
	if m.url != nil {
		fields = append(fields, contactdefault.FieldURL)
	}
	if m.category != nil {
		fields = append(fields, contactdefault.FieldCategory)
	}
	if m.custom_title != nil {
		fields = append(fields, contactdefault.FieldCustomTitle)
	}
	if m.description != nil {
		fields = append(fields, contactdefault.FieldDescription)
	}
	if m.created != nil {
		fields = append(fields, contactdefault.FieldCreated)
	}
	if m.modified != nil {
		fields = append(fields, contactdefault.FieldModified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContactDefaultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contactdefault.FieldName:
		return m.Name()
	case contactdefault.FieldEmail:
		return m.Email()
	case contactdefault.FieldURL:
		return m.URL()
	case contactdefault.FieldCategory:
		return m.Category()
	case contactdefault.FieldCustomTitle:
		return m.CustomTitle()
	case contactdefault.FieldDescription:
		return m.Description()
	case contactdefault.FieldCreated:
		return m.Created()
	case contactdefault.FieldModified:
		return m.Modified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContactDefaultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contactdefault.FieldName:
		return m.OldName(ctx)
	case contactdefault.FieldEmail:
		return m.OldEmail(ctx)
	case contactdefault.FieldURL:
		return m.OldURL(ctx)
	case contactdefault.FieldCategory:
		return m.OldCategory(ctx)
	case contactdefault.FieldCustomTitle:
		return m.OldCustomTitle(ctx)
	case contactdefault.FieldDescription:
		return m.OldDescription(ctx)
	case contactdefault.FieldCreated:
		return m.OldCreated(ctx)
	case contactdefault.FieldModified:
		return m.OldModified(ctx)
	}
	return nil, fmt.Errorf("unknown ContactDefault field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactDefaultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contactdefault.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case contactdefault.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case contactdefault.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case contactdefault.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case contactdefault.FieldCustomTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomTitle(v)
		return nil
	case contactdefault.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case contactdefault.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case contactdefault.FieldModified:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModified(v)
		return nil
	}
	return fmt.Errorf("unknown ContactDefault field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContactDefaultMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContactDefaultMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactDefaultMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ContactDefault numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContactDefaultMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contactdefault.FieldName) {
		fields = append(fields, contactdefault.FieldName)
	}
	if m.FieldCleared(contactdefault.FieldEmail) {
		fields = append(fields, contactdefault.FieldEmail)
	}
	if m.FieldCleared(contactdefault.FieldURL) {
		fields = append(fields, contactdefault.FieldURL)
	}
	if m.FieldCleared(contactdefault.FieldCategory) {
		fields = append(fields, contactdefault.FieldCategory)
	}
	if m.FieldCleared(contactdefault.FieldCustomTitle) {
		fields = append(fields, contactdefault.FieldCustomTitle)
	}
	if m.FieldCleared(contactdefault.FieldDescription) {
		fields = append(fields, contactdefault.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContactDefaultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContactDefaultMutation) ClearField(name string) error {
	switch name {
	case contactdefault.FieldName:
		m.ClearName()
		return nil
	case contactdefault.FieldEmail:
		m.ClearEmail()
		return nil
	case contactdefault.FieldURL:
		m.ClearURL()
		return nil
	case contactdefault.FieldCategory:
		m.ClearCategory()
		return nil
	case contactdefault.FieldCustomTitle:
		m.ClearCustomTitle()
		return nil
	case contactdefault.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ContactDefault nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContactDefaultMutation) ResetField(name string) error {
	switch name {
	case contactdefault.FieldName:
		m.ResetName()
		return nil
	case contactdefault.FieldEmail:
		m.ResetEmail()
		return nil
	case contactdefault.FieldURL:
		m.ResetURL()
		return nil
	case contactdefault.FieldCategory:
		m.ResetCategory()
		return nil
	case contactdefault.FieldCustomTitle:
		m.ResetCustomTitle()
		return nil
	case contactdefault.FieldDescription:
		m.ResetDescription()
		return nil
	case contactdefault.FieldCreated:
		m.ResetCreated()
		return nil
	case contactdefault.FieldModified:
		m.ResetModified()
		return nil
	}
	return fmt.Errorf("unknown ContactDefault field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContactDefaultMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContactDefaultMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContactDefaultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContactDefaultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContactDefaultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContactDefaultMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContactDefaultMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ContactDefault unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContactDefaultMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ContactDefault edge %s", name)
}

// LinkMutation represents an operation that mutates the Link nodes in the graph.
type LinkMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	user_id        *uint32
	adduser_id     *int32
	name           *string
	name_ja        *string
	site_url       *string
	favicon_url    *string
	category_id    *uint32
	addcategory_id *int32
	created        *time.Time
	modified       *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Link, error)
	predicates     []predicate.Link
}

var _ ent.Mutation = (*LinkMutation)(nil)

// linkOption allows management of the mutation configuration using functional options.
type linkOption func(*LinkMutation)

// newLinkMutation creates new mutation for the Link entity.
func newLinkMutation(c config, op Op, opts ...linkOption) *LinkMutation {
	m := &LinkMutation{
		config:        c,
		op:            op,
		typ:           TypeLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLinkID sets the ID field of the mutation.
func withLinkID(id uint32) linkOption {
	return func(m *LinkMutation) {
		var (
			err   error
			once  sync.Once
			value *Link
		)
		m.oldValue = func(ctx context.Context) (*Link, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Link.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLink sets the old Link of the mutation.
func withLink(node *Link) linkOption {
	return func(m *LinkMutation) {
		m.oldValue = func(context.Context) (*Link, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Link entities.
func (m *LinkMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LinkMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LinkMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Link.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *LinkMutation) SetUserID(u uint32) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LinkMutation) UserID() (r uint32, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldUserID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *LinkMutation) AddUserID(u int32) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *LinkMutation) AddedUserID() (r int32, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LinkMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetName sets the "name" field.
func (m *LinkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LinkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LinkMutation) ResetName() {
	m.name = nil
}

// SetNameJa sets the "name_ja" field.
func (m *LinkMutation) SetNameJa(s string) {
	m.name_ja = &s
}

// NameJa returns the value of the "name_ja" field in the mutation.
func (m *LinkMutation) NameJa() (r string, exists bool) {
	v := m.name_ja
	if v == nil {
		return
	}
	return *v, true
}

// OldNameJa returns the old "name_ja" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldNameJa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameJa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameJa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameJa: %w", err)
	}
	return oldValue.NameJa, nil
}

// ResetNameJa resets all changes to the "name_ja" field.
func (m *LinkMutation) ResetNameJa() {
	m.name_ja = nil
}

// SetSiteURL sets the "site_url" field.
func (m *LinkMutation) SetSiteURL(s string) {
	m.site_url = &s
}

// SiteURL returns the value of the "site_url" field in the mutation.
func (m *LinkMutation) SiteURL() (r string, exists bool) {
	v := m.site_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSiteURL returns the old "site_url" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldSiteURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSiteURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSiteURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSiteURL: %w", err)
	}
	return oldValue.SiteURL, nil
}

// ResetSiteURL resets all changes to the "site_url" field.
func (m *LinkMutation) ResetSiteURL() {
	m.site_url = nil
}

// SetFaviconURL sets the "favicon_url" field.
func (m *LinkMutation) SetFaviconURL(s string) {
	m.favicon_url = &s
}

// FaviconURL returns the value of the "favicon_url" field in the mutation.
func (m *LinkMutation) FaviconURL() (r string, exists bool) {
	v := m.favicon_url
	if v == nil {
		return
	}
	return *v, true
}

// OldFaviconURL returns the old "favicon_url" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldFaviconURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFaviconURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFaviconURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFaviconURL: %w", err)
	}
	return oldValue.FaviconURL, nil
}

// ClearFaviconURL clears the value of the "favicon_url" field.
func (m *LinkMutation) ClearFaviconURL() {
	m.favicon_url = nil
	m.clearedFields[link.FieldFaviconURL] = struct{}{}
}

// FaviconURLCleared returns if the "favicon_url" field was cleared in this mutation.
func (m *LinkMutation) FaviconURLCleared() bool {
	_, ok := m.clearedFields[link.FieldFaviconURL]
	return ok
}

// ResetFaviconURL resets all changes to the "favicon_url" field.
func (m *LinkMutation) ResetFaviconURL() {
	m.favicon_url = nil
	delete(m.clearedFields, link.FieldFaviconURL)
}

// SetCategoryID sets the "category_id" field.
func (m *LinkMutation) SetCategoryID(u uint32) {
	m.category_id = &u
	m.addcategory_id = nil
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *LinkMutation) CategoryID() (r uint32, exists bool) {
	v := m.category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldCategoryID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// AddCategoryID adds u to the "category_id" field.
func (m *LinkMutation) AddCategoryID(u int32) {
	if m.addcategory_id != nil {
		*m.addcategory_id += u
	} else {
		m.addcategory_id = &u
	}
}

// AddedCategoryID returns the value that was added to the "category_id" field in this mutation.
func (m *LinkMutation) AddedCategoryID() (r int32, exists bool) {
	v := m.addcategory_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *LinkMutation) ResetCategoryID() {
	m.category_id = nil
	m.addcategory_id = nil
}

// SetCreated sets the "created" field.
func (m *LinkMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *LinkMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ResetCreated resets all changes to the "created" field.
func (m *LinkMutation) ResetCreated() {
	m.created = nil
}

// SetModified sets the "modified" field.
func (m *LinkMutation) SetModified(t time.Time) {
	m.modified = &t
}

// Modified returns the value of the "modified" field in the mutation.
func (m *LinkMutation) Modified() (r time.Time, exists bool) {
	v := m.modified
	if v == nil {
		return
	}
	return *v, true
}

// OldModified returns the old "modified" field's value of the Link entity.
// If the Link object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LinkMutation) OldModified(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModified: %w", err)
	}
	return oldValue.Modified, nil
}

// ResetModified resets all changes to the "modified" field.
func (m *LinkMutation) ResetModified() {
	m.modified = nil
}

// Where appends a list predicates to the LinkMutation builder.
func (m *LinkMutation) Where(ps ...predicate.Link) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Link, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Link).
func (m *LinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LinkMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.user_id != nil {
		fields = append(fields, link.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, link.FieldName)
	}
	if m.name_ja != nil {
		fields = append(fields, link.FieldNameJa)
	}
	if m.site_url != nil {
		fields = append(fields, link.FieldSiteURL)
	}
	if m.favicon_url != nil {
		fields = append(fields, link.FieldFaviconURL)
	}
	if m.category_id != nil {
		fields = append(fields, link.FieldCategoryID)
	}
	if m.created != nil {
		fields = append(fields, link.FieldCreated)
	}
	if m.modified != nil {
		fields = append(fields, link.FieldModified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case link.FieldUserID:
		return m.UserID()
	case link.FieldName:
		return m.Name()
	case link.FieldNameJa:
		return m.NameJa()
	case link.FieldSiteURL:
		return m.SiteURL()
	case link.FieldFaviconURL:
		return m.FaviconURL()
	case link.FieldCategoryID:
		return m.CategoryID()
	case link.FieldCreated:
		return m.Created()
	case link.FieldModified:
		return m.Modified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case link.FieldUserID:
		return m.OldUserID(ctx)
	case link.FieldName:
		return m.OldName(ctx)
	case link.FieldNameJa:
		return m.OldNameJa(ctx)
	case link.FieldSiteURL:
		return m.OldSiteURL(ctx)
	case link.FieldFaviconURL:
		return m.OldFaviconURL(ctx)
	case link.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case link.FieldCreated:
		return m.OldCreated(ctx)
	case link.FieldModified:
		return m.OldModified(ctx)
	}
	return nil, fmt.Errorf("unknown Link field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case link.FieldUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case link.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case link.FieldNameJa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameJa(v)
		return nil
	case link.FieldSiteURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSiteURL(v)
		return nil
	case link.FieldFaviconURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFaviconURL(v)
		return nil
	case link.FieldCategoryID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case link.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case link.FieldModified:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModified(v)
		return nil
	}
	return fmt.Errorf("unknown Link field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LinkMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, link.FieldUserID)
	}
	if m.addcategory_id != nil {
		fields = append(fields, link.FieldCategoryID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LinkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case link.FieldUserID:
		return m.AddedUserID()
	case link.FieldCategoryID:
		return m.AddedCategoryID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case link.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case link.FieldCategoryID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown Link numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(link.FieldFaviconURL) {
		fields = append(fields, link.FieldFaviconURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LinkMutation) ClearField(name string) error {
	switch name {
	case link.FieldFaviconURL:
		m.ClearFaviconURL()
		return nil
	}
	return fmt.Errorf("unknown Link nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LinkMutation) ResetField(name string) error {
	switch name {
	case link.FieldUserID:
		m.ResetUserID()
		return nil
	case link.FieldName:
		m.ResetName()
		return nil
	case link.FieldNameJa:
		m.ResetNameJa()
		return nil
	case link.FieldSiteURL:
		m.ResetSiteURL()
		return nil
	case link.FieldFaviconURL:
		m.ResetFaviconURL()
		return nil
	case link.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case link.FieldCreated:
		m.ResetCreated()
		return nil
	case link.FieldModified:
		m.ResetModified()
		return nil
	}
	return fmt.Errorf("unknown Link field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LinkMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LinkMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LinkMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Link unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LinkMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Link edge %s", name)
}

// LocationMutation represents an operation that mutates the Location nodes in the graph.
type LocationMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	_type         *location.Type
	name          *string
	name_ja       *string
	address       *string
	address_ja    *string
	created       *time.Time
	modified      *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Location, error)
	predicates    []predicate.Location
}

var _ ent.Mutation = (*LocationMutation)(nil)

// locationOption allows management of the mutation configuration using functional options.
type locationOption func(*LocationMutation)

// newLocationMutation creates new mutation for the Location entity.
func newLocationMutation(c config, op Op, opts ...locationOption) *LocationMutation {
	m := &LocationMutation{
		config:        c,
		op:            op,
		typ:           TypeLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationID sets the ID field of the mutation.
func withLocationID(id uint32) locationOption {
	return func(m *LocationMutation) {
		var (
			err   error
			once  sync.Once
			value *Location
		)
		m.oldValue = func(ctx context.Context) (*Location, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Location.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocation sets the old Location of the mutation.
func withLocation(node *Location) locationOption {
	return func(m *LocationMutation) {
		m.oldValue = func(context.Context) (*Location, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Location entities.
func (m *LocationMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocationMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocationMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Location.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *LocationMutation) SetType(l location.Type) {
	m._type = &l
}

// GetType returns the value of the "type" field in the mutation.
func (m *LocationMutation) GetType() (r location.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldType(ctx context.Context) (v location.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *LocationMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *LocationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LocationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LocationMutation) ResetName() {
	m.name = nil
}

// SetNameJa sets the "name_ja" field.
func (m *LocationMutation) SetNameJa(s string) {
	m.name_ja = &s
}

// NameJa returns the value of the "name_ja" field in the mutation.
func (m *LocationMutation) NameJa() (r string, exists bool) {
	v := m.name_ja
	if v == nil {
		return
	}
	return *v, true
}

// OldNameJa returns the old "name_ja" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldNameJa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameJa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameJa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameJa: %w", err)
	}
	return oldValue.NameJa, nil
}

// ResetNameJa resets all changes to the "name_ja" field.
func (m *LocationMutation) ResetNameJa() {
	m.name_ja = nil
}

// SetAddress sets the "address" field.
func (m *LocationMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *LocationMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *LocationMutation) ResetAddress() {
	m.address = nil
}

// SetAddressJa sets the "address_ja" field.
func (m *LocationMutation) SetAddressJa(s string) {
	m.address_ja = &s
}

// AddressJa returns the value of the "address_ja" field in the mutation.
func (m *LocationMutation) AddressJa() (r string, exists bool) {
	v := m.address_ja
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressJa returns the old "address_ja" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldAddressJa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressJa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressJa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressJa: %w", err)
	}
	return oldValue.AddressJa, nil
}

// ResetAddressJa resets all changes to the "address_ja" field.
func (m *LocationMutation) ResetAddressJa() {
	m.address_ja = nil
}

// SetCreated sets the "created" field.
func (m *LocationMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *LocationMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ResetCreated resets all changes to the "created" field.
func (m *LocationMutation) ResetCreated() {
	m.created = nil
}

// SetModified sets the "modified" field.
func (m *LocationMutation) SetModified(t time.Time) {
	m.modified = &t
}

// Modified returns the value of the "modified" field in the mutation.
func (m *LocationMutation) Modified() (r time.Time, exists bool) {
	v := m.modified
	if v == nil {
		return
	}
	return *v, true
}

// OldModified returns the old "modified" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldModified(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModified: %w", err)
	}
	return oldValue.Modified, nil
}

// ResetModified resets all changes to the "modified" field.
func (m *LocationMutation) ResetModified() {
	m.modified = nil
}

// Where appends a list predicates to the LocationMutation builder.
func (m *LocationMutation) Where(ps ...predicate.Location) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Location, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Location).
func (m *LocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._type != nil {
		fields = append(fields, location.FieldType)
	}
	if m.name != nil {
		fields = append(fields, location.FieldName)
	}
	if m.name_ja != nil {
		fields = append(fields, location.FieldNameJa)
	}
	if m.address != nil {
		fields = append(fields, location.FieldAddress)
	}
	if m.address_ja != nil {
		fields = append(fields, location.FieldAddressJa)
	}
	if m.created != nil {
		fields = append(fields, location.FieldCreated)
	}
	if m.modified != nil {
		fields = append(fields, location.FieldModified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case location.FieldType:
		return m.GetType()
	case location.FieldName:
		return m.Name()
	case location.FieldNameJa:
		return m.NameJa()
	case location.FieldAddress:
		return m.Address()
	case location.FieldAddressJa:
		return m.AddressJa()
	case location.FieldCreated:
		return m.Created()
	case location.FieldModified:
		return m.Modified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case location.FieldType:
		return m.OldType(ctx)
	case location.FieldName:
		return m.OldName(ctx)
	case location.FieldNameJa:
		return m.OldNameJa(ctx)
	case location.FieldAddress:
		return m.OldAddress(ctx)
	case location.FieldAddressJa:
		return m.OldAddressJa(ctx)
	case location.FieldCreated:
		return m.OldCreated(ctx)
	case location.FieldModified:
		return m.OldModified(ctx)
	}
	return nil, fmt.Errorf("unknown Location field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case location.FieldType:
		v, ok := value.(location.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case location.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case location.FieldNameJa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameJa(v)
		return nil
	case location.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case location.FieldAddressJa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressJa(v)
		return nil
	case location.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case location.FieldModified:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModified(v)
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Location numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Location nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocationMutation) ResetField(name string) error {
	switch name {
	case location.FieldType:
		m.ResetType()
		return nil
	case location.FieldName:
		m.ResetName()
		return nil
	case location.FieldNameJa:
		m.ResetNameJa()
		return nil
	case location.FieldAddress:
		m.ResetAddress()
		return nil
	case location.FieldAddressJa:
		m.ResetAddressJa()
		return nil
	case location.FieldCreated:
		m.ResetCreated()
		return nil
	case location.FieldModified:
		m.ResetModified()
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Location unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Location edge %s", name)
}

// NoticeMutation represents an operation that mutates the Notice nodes in the graph.
type NoticeMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	user_id         *uint32
	adduser_id      *int32
	discord_webhook *string
	slack_webhook   *string
	mail            *string
	created         *time.Time
	modified        *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Notice, error)
	predicates      []predicate.Notice
}

var _ ent.Mutation = (*NoticeMutation)(nil)

// noticeOption allows management of the mutation configuration using functional options.
type noticeOption func(*NoticeMutation)

// newNoticeMutation creates new mutation for the Notice entity.
func newNoticeMutation(c config, op Op, opts ...noticeOption) *NoticeMutation {
	m := &NoticeMutation{
		config:        c,
		op:            op,
		typ:           TypeNotice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNoticeID sets the ID field of the mutation.
func withNoticeID(id uint32) noticeOption {
	return func(m *NoticeMutation) {
		var (
			err   error
			once  sync.Once
			value *Notice
		)
		m.oldValue = func(ctx context.Context) (*Notice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotice sets the old Notice of the mutation.
func withNotice(node *Notice) noticeOption {
	return func(m *NoticeMutation) {
		m.oldValue = func(context.Context) (*Notice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NoticeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NoticeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Notice entities.
func (m *NoticeMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NoticeMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NoticeMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *NoticeMutation) SetUserID(u uint32) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *NoticeMutation) UserID() (r uint32, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Notice entity.
// If the Notice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoticeMutation) OldUserID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *NoticeMutation) AddUserID(u int32) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *NoticeMutation) AddedUserID() (r int32, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *NoticeMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetDiscordWebhook sets the "discord_webhook" field.
func (m *NoticeMutation) SetDiscordWebhook(s string) {
	m.discord_webhook = &s
}

// DiscordWebhook returns the value of the "discord_webhook" field in the mutation.
func (m *NoticeMutation) DiscordWebhook() (r string, exists bool) {
	v := m.discord_webhook
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscordWebhook returns the old "discord_webhook" field's value of the Notice entity.
// If the Notice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoticeMutation) OldDiscordWebhook(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscordWebhook is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscordWebhook requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscordWebhook: %w", err)
	}
	return oldValue.DiscordWebhook, nil
}

// ClearDiscordWebhook clears the value of the "discord_webhook" field.
func (m *NoticeMutation) ClearDiscordWebhook() {
	m.discord_webhook = nil
	m.clearedFields[notice.FieldDiscordWebhook] = struct{}{}
}

// DiscordWebhookCleared returns if the "discord_webhook" field was cleared in this mutation.
func (m *NoticeMutation) DiscordWebhookCleared() bool {
	_, ok := m.clearedFields[notice.FieldDiscordWebhook]
	return ok
}

// ResetDiscordWebhook resets all changes to the "discord_webhook" field.
func (m *NoticeMutation) ResetDiscordWebhook() {
	m.discord_webhook = nil
	delete(m.clearedFields, notice.FieldDiscordWebhook)
}

// SetSlackWebhook sets the "slack_webhook" field.
func (m *NoticeMutation) SetSlackWebhook(s string) {
	m.slack_webhook = &s
}

// SlackWebhook returns the value of the "slack_webhook" field in the mutation.
func (m *NoticeMutation) SlackWebhook() (r string, exists bool) {
	v := m.slack_webhook
	if v == nil {
		return
	}
	return *v, true
}

// OldSlackWebhook returns the old "slack_webhook" field's value of the Notice entity.
// If the Notice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoticeMutation) OldSlackWebhook(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlackWebhook is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlackWebhook requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlackWebhook: %w", err)
	}
	return oldValue.SlackWebhook, nil
}

// ClearSlackWebhook clears the value of the "slack_webhook" field.
func (m *NoticeMutation) ClearSlackWebhook() {
	m.slack_webhook = nil
	m.clearedFields[notice.FieldSlackWebhook] = struct{}{}
}

// SlackWebhookCleared returns if the "slack_webhook" field was cleared in this mutation.
func (m *NoticeMutation) SlackWebhookCleared() bool {
	_, ok := m.clearedFields[notice.FieldSlackWebhook]
	return ok
}

// ResetSlackWebhook resets all changes to the "slack_webhook" field.
func (m *NoticeMutation) ResetSlackWebhook() {
	m.slack_webhook = nil
	delete(m.clearedFields, notice.FieldSlackWebhook)
}

// SetMail sets the "mail" field.
func (m *NoticeMutation) SetMail(s string) {
	m.mail = &s
}

// Mail returns the value of the "mail" field in the mutation.
func (m *NoticeMutation) Mail() (r string, exists bool) {
	v := m.mail
	if v == nil {
		return
	}
	return *v, true
}

// OldMail returns the old "mail" field's value of the Notice entity.
// If the Notice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoticeMutation) OldMail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMail: %w", err)
	}
	return oldValue.Mail, nil
}

// ClearMail clears the value of the "mail" field.
func (m *NoticeMutation) ClearMail() {
	m.mail = nil
	m.clearedFields[notice.FieldMail] = struct{}{}
}

// MailCleared returns if the "mail" field was cleared in this mutation.
func (m *NoticeMutation) MailCleared() bool {
	_, ok := m.clearedFields[notice.FieldMail]
	return ok
}

// ResetMail resets all changes to the "mail" field.
func (m *NoticeMutation) ResetMail() {
	m.mail = nil
	delete(m.clearedFields, notice.FieldMail)
}

// SetCreated sets the "created" field.
func (m *NoticeMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *NoticeMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the Notice entity.
// If the Notice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoticeMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ResetCreated resets all changes to the "created" field.
func (m *NoticeMutation) ResetCreated() {
	m.created = nil
}

// SetModified sets the "modified" field.
func (m *NoticeMutation) SetModified(t time.Time) {
	m.modified = &t
}

// Modified returns the value of the "modified" field in the mutation.
func (m *NoticeMutation) Modified() (r time.Time, exists bool) {
	v := m.modified
	if v == nil {
		return
	}
	return *v, true
}

// OldModified returns the old "modified" field's value of the Notice entity.
// If the Notice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoticeMutation) OldModified(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModified: %w", err)
	}
	return oldValue.Modified, nil
}

// ResetModified resets all changes to the "modified" field.
func (m *NoticeMutation) ResetModified() {
	m.modified = nil
}

// Where appends a list predicates to the NoticeMutation builder.
func (m *NoticeMutation) Where(ps ...predicate.Notice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NoticeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NoticeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NoticeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NoticeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notice).
func (m *NoticeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NoticeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.user_id != nil {
		fields = append(fields, notice.FieldUserID)
	}
	if m.discord_webhook != nil {
		fields = append(fields, notice.FieldDiscordWebhook)
	}
	if m.slack_webhook != nil {
		fields = append(fields, notice.FieldSlackWebhook)
	}
	if m.mail != nil {
		fields = append(fields, notice.FieldMail)
	}
	if m.created != nil {
		fields = append(fields, notice.FieldCreated)
	}
	if m.modified != nil {
		fields = append(fields, notice.FieldModified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NoticeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notice.FieldUserID:
		return m.UserID()
	case notice.FieldDiscordWebhook:
		return m.DiscordWebhook()
	case notice.FieldSlackWebhook:
		return m.SlackWebhook()
	case notice.FieldMail:
		return m.Mail()
	case notice.FieldCreated:
		return m.Created()
	case notice.FieldModified:
		return m.Modified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NoticeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notice.FieldUserID:
		return m.OldUserID(ctx)
	case notice.FieldDiscordWebhook:
		return m.OldDiscordWebhook(ctx)
	case notice.FieldSlackWebhook:
		return m.OldSlackWebhook(ctx)
	case notice.FieldMail:
		return m.OldMail(ctx)
	case notice.FieldCreated:
		return m.OldCreated(ctx)
	case notice.FieldModified:
		return m.OldModified(ctx)
	}
	return nil, fmt.Errorf("unknown Notice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NoticeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notice.FieldUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case notice.FieldDiscordWebhook:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscordWebhook(v)
		return nil
	case notice.FieldSlackWebhook:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlackWebhook(v)
		return nil
	case notice.FieldMail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMail(v)
		return nil
	case notice.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case notice.FieldModified:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModified(v)
		return nil
	}
	return fmt.Errorf("unknown Notice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NoticeMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, notice.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NoticeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case notice.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NoticeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case notice.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Notice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NoticeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notice.FieldDiscordWebhook) {
		fields = append(fields, notice.FieldDiscordWebhook)
	}
	if m.FieldCleared(notice.FieldSlackWebhook) {
		fields = append(fields, notice.FieldSlackWebhook)
	}
	if m.FieldCleared(notice.FieldMail) {
		fields = append(fields, notice.FieldMail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NoticeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NoticeMutation) ClearField(name string) error {
	switch name {
	case notice.FieldDiscordWebhook:
		m.ClearDiscordWebhook()
		return nil
	case notice.FieldSlackWebhook:
		m.ClearSlackWebhook()
		return nil
	case notice.FieldMail:
		m.ClearMail()
		return nil
	}
	return fmt.Errorf("unknown Notice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NoticeMutation) ResetField(name string) error {
	switch name {
	case notice.FieldUserID:
		m.ResetUserID()
		return nil
	case notice.FieldDiscordWebhook:
		m.ResetDiscordWebhook()
		return nil
	case notice.FieldSlackWebhook:
		m.ResetSlackWebhook()
		return nil
	case notice.FieldMail:
		m.ResetMail()
		return nil
	case notice.FieldCreated:
		m.ResetCreated()
		return nil
	case notice.FieldModified:
		m.ResetModified()
		return nil
	}
	return fmt.Errorf("unknown Notice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NoticeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NoticeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NoticeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NoticeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NoticeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NoticeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NoticeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Notice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NoticeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Notice edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	user_id       *uint32
	adduser_id    *int32
	name          *string
	name_ja       *string
	detail        *string
	detail_ja     *string
	site_url      *string
	github_url    *string
	dev_time      *time.Time
	thumbnail     *string
	created       *time.Time
	modified      *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Product, error)
	predicates    []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id uint32) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Product entities.
func (m *ProductMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *ProductMutation) SetUserID(u uint32) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ProductMutation) UserID() (r uint32, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUserID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *ProductMutation) AddUserID(u int32) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *ProductMutation) AddedUserID() (r int32, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ProductMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
}

// SetNameJa sets the "name_ja" field.
func (m *ProductMutation) SetNameJa(s string) {
	m.name_ja = &s
}

// NameJa returns the value of the "name_ja" field in the mutation.
func (m *ProductMutation) NameJa() (r string, exists bool) {
	v := m.name_ja
	if v == nil {
		return
	}
	return *v, true
}

// OldNameJa returns the old "name_ja" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldNameJa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameJa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameJa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameJa: %w", err)
	}
	return oldValue.NameJa, nil
}

// ResetNameJa resets all changes to the "name_ja" field.
func (m *ProductMutation) ResetNameJa() {
	m.name_ja = nil
}

// SetDetail sets the "detail" field.
func (m *ProductMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *ProductMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ResetDetail resets all changes to the "detail" field.
func (m *ProductMutation) ResetDetail() {
	m.detail = nil
}

// SetDetailJa sets the "detail_ja" field.
func (m *ProductMutation) SetDetailJa(s string) {
	m.detail_ja = &s
}

// DetailJa returns the value of the "detail_ja" field in the mutation.
func (m *ProductMutation) DetailJa() (r string, exists bool) {
	v := m.detail_ja
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailJa returns the old "detail_ja" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDetailJa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetailJa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetailJa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailJa: %w", err)
	}
	return oldValue.DetailJa, nil
}

// ResetDetailJa resets all changes to the "detail_ja" field.
func (m *ProductMutation) ResetDetailJa() {
	m.detail_ja = nil
}

// SetSiteURL sets the "site_url" field.
func (m *ProductMutation) SetSiteURL(s string) {
	m.site_url = &s
}

// SiteURL returns the value of the "site_url" field in the mutation.
func (m *ProductMutation) SiteURL() (r string, exists bool) {
	v := m.site_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSiteURL returns the old "site_url" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSiteURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSiteURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSiteURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSiteURL: %w", err)
	}
	return oldValue.SiteURL, nil
}

// ResetSiteURL resets all changes to the "site_url" field.
func (m *ProductMutation) ResetSiteURL() {
	m.site_url = nil
}

// SetGithubURL sets the "github_url" field.
func (m *ProductMutation) SetGithubURL(s string) {
	m.github_url = &s
}

// GithubURL returns the value of the "github_url" field in the mutation.
func (m *ProductMutation) GithubURL() (r string, exists bool) {
	v := m.github_url
	if v == nil {
		return
	}
	return *v, true
}

// OldGithubURL returns the old "github_url" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldGithubURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGithubURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGithubURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithubURL: %w", err)
	}
	return oldValue.GithubURL, nil
}

// ClearGithubURL clears the value of the "github_url" field.
func (m *ProductMutation) ClearGithubURL() {
	m.github_url = nil
	m.clearedFields[product.FieldGithubURL] = struct{}{}
}

// GithubURLCleared returns if the "github_url" field was cleared in this mutation.
func (m *ProductMutation) GithubURLCleared() bool {
	_, ok := m.clearedFields[product.FieldGithubURL]
	return ok
}

// ResetGithubURL resets all changes to the "github_url" field.
func (m *ProductMutation) ResetGithubURL() {
	m.github_url = nil
	delete(m.clearedFields, product.FieldGithubURL)
}

// SetDevTime sets the "dev_time" field.
func (m *ProductMutation) SetDevTime(t time.Time) {
	m.dev_time = &t
}

// DevTime returns the value of the "dev_time" field in the mutation.
func (m *ProductMutation) DevTime() (r time.Time, exists bool) {
	v := m.dev_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDevTime returns the old "dev_time" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDevTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDevTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDevTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevTime: %w", err)
	}
	return oldValue.DevTime, nil
}

// ResetDevTime resets all changes to the "dev_time" field.
func (m *ProductMutation) ResetDevTime() {
	m.dev_time = nil
}

// SetThumbnail sets the "thumbnail" field.
func (m *ProductMutation) SetThumbnail(s string) {
	m.thumbnail = &s
}

// Thumbnail returns the value of the "thumbnail" field in the mutation.
func (m *ProductMutation) Thumbnail() (r string, exists bool) {
	v := m.thumbnail
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnail returns the old "thumbnail" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldThumbnail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnail: %w", err)
	}
	return oldValue.Thumbnail, nil
}

// ClearThumbnail clears the value of the "thumbnail" field.
func (m *ProductMutation) ClearThumbnail() {
	m.thumbnail = nil
	m.clearedFields[product.FieldThumbnail] = struct{}{}
}

// ThumbnailCleared returns if the "thumbnail" field was cleared in this mutation.
func (m *ProductMutation) ThumbnailCleared() bool {
	_, ok := m.clearedFields[product.FieldThumbnail]
	return ok
}

// ResetThumbnail resets all changes to the "thumbnail" field.
func (m *ProductMutation) ResetThumbnail() {
	m.thumbnail = nil
	delete(m.clearedFields, product.FieldThumbnail)
}

// SetCreated sets the "created" field.
func (m *ProductMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *ProductMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ResetCreated resets all changes to the "created" field.
func (m *ProductMutation) ResetCreated() {
	m.created = nil
}

// SetModified sets the "modified" field.
func (m *ProductMutation) SetModified(t time.Time) {
	m.modified = &t
}

// Modified returns the value of the "modified" field in the mutation.
func (m *ProductMutation) Modified() (r time.Time, exists bool) {
	v := m.modified
	if v == nil {
		return
	}
	return *v, true
}

// OldModified returns the old "modified" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldModified(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModified: %w", err)
	}
	return oldValue.Modified, nil
}

// ResetModified resets all changes to the "modified" field.
func (m *ProductMutation) ResetModified() {
	m.modified = nil
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.user_id != nil {
		fields = append(fields, product.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.name_ja != nil {
		fields = append(fields, product.FieldNameJa)
	}
	if m.detail != nil {
		fields = append(fields, product.FieldDetail)
	}
	if m.detail_ja != nil {
		fields = append(fields, product.FieldDetailJa)
	}
	if m.site_url != nil {
		fields = append(fields, product.FieldSiteURL)
	}
	if m.github_url != nil {
		fields = append(fields, product.FieldGithubURL)
	}
	if m.dev_time != nil {
		fields = append(fields, product.FieldDevTime)
	}
	if m.thumbnail != nil {
		fields = append(fields, product.FieldThumbnail)
	}
	if m.created != nil {
		fields = append(fields, product.FieldCreated)
	}
	if m.modified != nil {
		fields = append(fields, product.FieldModified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldUserID:
		return m.UserID()
	case product.FieldName:
		return m.Name()
	case product.FieldNameJa:
		return m.NameJa()
	case product.FieldDetail:
		return m.Detail()
	case product.FieldDetailJa:
		return m.DetailJa()
	case product.FieldSiteURL:
		return m.SiteURL()
	case product.FieldGithubURL:
		return m.GithubURL()
	case product.FieldDevTime:
		return m.DevTime()
	case product.FieldThumbnail:
		return m.Thumbnail()
	case product.FieldCreated:
		return m.Created()
	case product.FieldModified:
		return m.Modified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldUserID:
		return m.OldUserID(ctx)
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldNameJa:
		return m.OldNameJa(ctx)
	case product.FieldDetail:
		return m.OldDetail(ctx)
	case product.FieldDetailJa:
		return m.OldDetailJa(ctx)
	case product.FieldSiteURL:
		return m.OldSiteURL(ctx)
	case product.FieldGithubURL:
		return m.OldGithubURL(ctx)
	case product.FieldDevTime:
		return m.OldDevTime(ctx)
	case product.FieldThumbnail:
		return m.OldThumbnail(ctx)
	case product.FieldCreated:
		return m.OldCreated(ctx)
	case product.FieldModified:
		return m.OldModified(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldNameJa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameJa(v)
		return nil
	case product.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case product.FieldDetailJa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailJa(v)
		return nil
	case product.FieldSiteURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSiteURL(v)
		return nil
	case product.FieldGithubURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithubURL(v)
		return nil
	case product.FieldDevTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevTime(v)
		return nil
	case product.FieldThumbnail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnail(v)
		return nil
	case product.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case product.FieldModified:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModified(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, product.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldGithubURL) {
		fields = append(fields, product.FieldGithubURL)
	}
	if m.FieldCleared(product.FieldThumbnail) {
		fields = append(fields, product.FieldThumbnail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldGithubURL:
		m.ClearGithubURL()
		return nil
	case product.FieldThumbnail:
		m.ClearThumbnail()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldUserID:
		m.ResetUserID()
		return nil
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldNameJa:
		m.ResetNameJa()
		return nil
	case product.FieldDetail:
		m.ResetDetail()
		return nil
	case product.FieldDetailJa:
		m.ResetDetailJa()
		return nil
	case product.FieldSiteURL:
		m.ResetSiteURL()
		return nil
	case product.FieldGithubURL:
		m.ResetGithubURL()
		return nil
	case product.FieldDevTime:
		m.ResetDevTime()
		return nil
	case product.FieldThumbnail:
		m.ResetThumbnail()
		return nil
	case product.FieldCreated:
		m.ResetCreated()
		return nil
	case product.FieldModified:
		m.ResetModified()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Product edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	user_id       *uint32
	adduser_id    *int32
	created       *time.Time
	period        *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Session, error)
	predicates    []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id uuid.UUID) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *SessionMutation) SetUserID(u uint32) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SessionMutation) UserID() (r uint32, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *SessionMutation) AddUserID(u int32) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *SessionMutation) AddedUserID() (r int32, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SessionMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetCreated sets the "created" field.
func (m *SessionMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *SessionMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ResetCreated resets all changes to the "created" field.
func (m *SessionMutation) ResetCreated() {
	m.created = nil
}

// SetPeriod sets the "period" field.
func (m *SessionMutation) SetPeriod(t time.Time) {
	m.period = &t
}

// Period returns the value of the "period" field in the mutation.
func (m *SessionMutation) Period() (r time.Time, exists bool) {
	v := m.period
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriod returns the old "period" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldPeriod(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriod: %w", err)
	}
	return oldValue.Period, nil
}

// ResetPeriod resets all changes to the "period" field.
func (m *SessionMutation) ResetPeriod() {
	m.period = nil
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user_id != nil {
		fields = append(fields, session.FieldUserID)
	}
	if m.created != nil {
		fields = append(fields, session.FieldCreated)
	}
	if m.period != nil {
		fields = append(fields, session.FieldPeriod)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldUserID:
		return m.UserID()
	case session.FieldCreated:
		return m.Created()
	case session.FieldPeriod:
		return m.Period()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldUserID:
		return m.OldUserID(ctx)
	case session.FieldCreated:
		return m.OldCreated(ctx)
	case session.FieldPeriod:
		return m.OldPeriod(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case session.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case session.FieldPeriod:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriod(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, session.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case session.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case session.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldUserID:
		m.ResetUserID()
		return nil
	case session.FieldCreated:
		m.ResetCreated()
		return nil
	case session.FieldPeriod:
		m.ResetPeriod()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Session edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op             Op
	typ            string
	id             *uint32
	given_name     *string
	family_name    *string
	given_name_ja  *string
	family_name_ja *string
	user_id        *string
	mail           *string
	birth_date     *time.Time
	location       *string
	location_ja    *string
	sso_token      *string
	avatar_url     *string
	selected       *bool
	created        *time.Time
	modified       *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*User, error)
	predicates     []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uint32) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGivenName sets the "given_name" field.
func (m *UserMutation) SetGivenName(s string) {
	m.given_name = &s
}

// GivenName returns the value of the "given_name" field in the mutation.
func (m *UserMutation) GivenName() (r string, exists bool) {
	v := m.given_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGivenName returns the old "given_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGivenName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGivenName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGivenName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGivenName: %w", err)
	}
	return oldValue.GivenName, nil
}

// ResetGivenName resets all changes to the "given_name" field.
func (m *UserMutation) ResetGivenName() {
	m.given_name = nil
}

// SetFamilyName sets the "family_name" field.
func (m *UserMutation) SetFamilyName(s string) {
	m.family_name = &s
}

// FamilyName returns the value of the "family_name" field in the mutation.
func (m *UserMutation) FamilyName() (r string, exists bool) {
	v := m.family_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFamilyName returns the old "family_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFamilyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFamilyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFamilyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFamilyName: %w", err)
	}
	return oldValue.FamilyName, nil
}

// ResetFamilyName resets all changes to the "family_name" field.
func (m *UserMutation) ResetFamilyName() {
	m.family_name = nil
}

// SetGivenNameJa sets the "given_name_ja" field.
func (m *UserMutation) SetGivenNameJa(s string) {
	m.given_name_ja = &s
}

// GivenNameJa returns the value of the "given_name_ja" field in the mutation.
func (m *UserMutation) GivenNameJa() (r string, exists bool) {
	v := m.given_name_ja
	if v == nil {
		return
	}
	return *v, true
}

// OldGivenNameJa returns the old "given_name_ja" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGivenNameJa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGivenNameJa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGivenNameJa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGivenNameJa: %w", err)
	}
	return oldValue.GivenNameJa, nil
}

// ResetGivenNameJa resets all changes to the "given_name_ja" field.
func (m *UserMutation) ResetGivenNameJa() {
	m.given_name_ja = nil
}

// SetFamilyNameJa sets the "family_name_ja" field.
func (m *UserMutation) SetFamilyNameJa(s string) {
	m.family_name_ja = &s
}

// FamilyNameJa returns the value of the "family_name_ja" field in the mutation.
func (m *UserMutation) FamilyNameJa() (r string, exists bool) {
	v := m.family_name_ja
	if v == nil {
		return
	}
	return *v, true
}

// OldFamilyNameJa returns the old "family_name_ja" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFamilyNameJa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFamilyNameJa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFamilyNameJa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFamilyNameJa: %w", err)
	}
	return oldValue.FamilyNameJa, nil
}

// ResetFamilyNameJa resets all changes to the "family_name_ja" field.
func (m *UserMutation) ResetFamilyNameJa() {
	m.family_name_ja = nil
}

// SetUserID sets the "user_id" field.
func (m *UserMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserMutation) ResetUserID() {
	m.user_id = nil
}

// SetMail sets the "mail" field.
func (m *UserMutation) SetMail(s string) {
	m.mail = &s
}

// Mail returns the value of the "mail" field in the mutation.
func (m *UserMutation) Mail() (r string, exists bool) {
	v := m.mail
	if v == nil {
		return
	}
	return *v, true
}

// OldMail returns the old "mail" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMail: %w", err)
	}
	return oldValue.Mail, nil
}

// ResetMail resets all changes to the "mail" field.
func (m *UserMutation) ResetMail() {
	m.mail = nil
}

// SetBirthDate sets the "birth_date" field.
func (m *UserMutation) SetBirthDate(t time.Time) {
	m.birth_date = &t
}

// BirthDate returns the value of the "birth_date" field in the mutation.
func (m *UserMutation) BirthDate() (r time.Time, exists bool) {
	v := m.birth_date
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthDate returns the old "birth_date" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBirthDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthDate: %w", err)
	}
	return oldValue.BirthDate, nil
}

// ResetBirthDate resets all changes to the "birth_date" field.
func (m *UserMutation) ResetBirthDate() {
	m.birth_date = nil
}

// SetLocation sets the "location" field.
func (m *UserMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *UserMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *UserMutation) ResetLocation() {
	m.location = nil
}

// SetLocationJa sets the "location_ja" field.
func (m *UserMutation) SetLocationJa(s string) {
	m.location_ja = &s
}

// LocationJa returns the value of the "location_ja" field in the mutation.
func (m *UserMutation) LocationJa() (r string, exists bool) {
	v := m.location_ja
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationJa returns the old "location_ja" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLocationJa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationJa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationJa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationJa: %w", err)
	}
	return oldValue.LocationJa, nil
}

// ResetLocationJa resets all changes to the "location_ja" field.
func (m *UserMutation) ResetLocationJa() {
	m.location_ja = nil
}

// SetSSOToken sets the "sso_token" field.
func (m *UserMutation) SetSSOToken(s string) {
	m.sso_token = &s
}

// SSOToken returns the value of the "sso_token" field in the mutation.
func (m *UserMutation) SSOToken() (r string, exists bool) {
	v := m.sso_token
	if v == nil {
		return
	}
	return *v, true
}

// OldSSOToken returns the old "sso_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSSOToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSSOToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSSOToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSSOToken: %w", err)
	}
	return oldValue.SSOToken, nil
}

// ResetSSOToken resets all changes to the "sso_token" field.
func (m *UserMutation) ResetSSOToken() {
	m.sso_token = nil
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *UserMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[user.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *UserMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, user.FieldAvatarURL)
}

// SetSelected sets the "selected" field.
func (m *UserMutation) SetSelected(b bool) {
	m.selected = &b
}

// Selected returns the value of the "selected" field in the mutation.
func (m *UserMutation) Selected() (r bool, exists bool) {
	v := m.selected
	if v == nil {
		return
	}
	return *v, true
}

// OldSelected returns the old "selected" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSelected(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelected: %w", err)
	}
	return oldValue.Selected, nil
}

// ResetSelected resets all changes to the "selected" field.
func (m *UserMutation) ResetSelected() {
	m.selected = nil
}

// SetCreated sets the "created" field.
func (m *UserMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *UserMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ResetCreated resets all changes to the "created" field.
func (m *UserMutation) ResetCreated() {
	m.created = nil
}

// SetModified sets the "modified" field.
func (m *UserMutation) SetModified(t time.Time) {
	m.modified = &t
}

// Modified returns the value of the "modified" field in the mutation.
func (m *UserMutation) Modified() (r time.Time, exists bool) {
	v := m.modified
	if v == nil {
		return
	}
	return *v, true
}

// OldModified returns the old "modified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldModified(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModified: %w", err)
	}
	return oldValue.Modified, nil
}

// ResetModified resets all changes to the "modified" field.
func (m *UserMutation) ResetModified() {
	m.modified = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.given_name != nil {
		fields = append(fields, user.FieldGivenName)
	}
	if m.family_name != nil {
		fields = append(fields, user.FieldFamilyName)
	}
	if m.given_name_ja != nil {
		fields = append(fields, user.FieldGivenNameJa)
	}
	if m.family_name_ja != nil {
		fields = append(fields, user.FieldFamilyNameJa)
	}
	if m.user_id != nil {
		fields = append(fields, user.FieldUserID)
	}
	if m.mail != nil {
		fields = append(fields, user.FieldMail)
	}
	if m.birth_date != nil {
		fields = append(fields, user.FieldBirthDate)
	}
	if m.location != nil {
		fields = append(fields, user.FieldLocation)
	}
	if m.location_ja != nil {
		fields = append(fields, user.FieldLocationJa)
	}
	if m.sso_token != nil {
		fields = append(fields, user.FieldSSOToken)
	}
	if m.avatar_url != nil {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.selected != nil {
		fields = append(fields, user.FieldSelected)
	}
	if m.created != nil {
		fields = append(fields, user.FieldCreated)
	}
	if m.modified != nil {
		fields = append(fields, user.FieldModified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldGivenName:
		return m.GivenName()
	case user.FieldFamilyName:
		return m.FamilyName()
	case user.FieldGivenNameJa:
		return m.GivenNameJa()
	case user.FieldFamilyNameJa:
		return m.FamilyNameJa()
	case user.FieldUserID:
		return m.UserID()
	case user.FieldMail:
		return m.Mail()
	case user.FieldBirthDate:
		return m.BirthDate()
	case user.FieldLocation:
		return m.Location()
	case user.FieldLocationJa:
		return m.LocationJa()
	case user.FieldSSOToken:
		return m.SSOToken()
	case user.FieldAvatarURL:
		return m.AvatarURL()
	case user.FieldSelected:
		return m.Selected()
	case user.FieldCreated:
		return m.Created()
	case user.FieldModified:
		return m.Modified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldGivenName:
		return m.OldGivenName(ctx)
	case user.FieldFamilyName:
		return m.OldFamilyName(ctx)
	case user.FieldGivenNameJa:
		return m.OldGivenNameJa(ctx)
	case user.FieldFamilyNameJa:
		return m.OldFamilyNameJa(ctx)
	case user.FieldUserID:
		return m.OldUserID(ctx)
	case user.FieldMail:
		return m.OldMail(ctx)
	case user.FieldBirthDate:
		return m.OldBirthDate(ctx)
	case user.FieldLocation:
		return m.OldLocation(ctx)
	case user.FieldLocationJa:
		return m.OldLocationJa(ctx)
	case user.FieldSSOToken:
		return m.OldSSOToken(ctx)
	case user.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case user.FieldSelected:
		return m.OldSelected(ctx)
	case user.FieldCreated:
		return m.OldCreated(ctx)
	case user.FieldModified:
		return m.OldModified(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldGivenName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGivenName(v)
		return nil
	case user.FieldFamilyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFamilyName(v)
		return nil
	case user.FieldGivenNameJa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGivenNameJa(v)
		return nil
	case user.FieldFamilyNameJa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFamilyNameJa(v)
		return nil
	case user.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case user.FieldMail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMail(v)
		return nil
	case user.FieldBirthDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthDate(v)
		return nil
	case user.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case user.FieldLocationJa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationJa(v)
		return nil
	case user.FieldSSOToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSSOToken(v)
		return nil
	case user.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case user.FieldSelected:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelected(v)
		return nil
	case user.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case user.FieldModified:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModified(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldAvatarURL) {
		fields = append(fields, user.FieldAvatarURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldGivenName:
		m.ResetGivenName()
		return nil
	case user.FieldFamilyName:
		m.ResetFamilyName()
		return nil
	case user.FieldGivenNameJa:
		m.ResetGivenNameJa()
		return nil
	case user.FieldFamilyNameJa:
		m.ResetFamilyNameJa()
		return nil
	case user.FieldUserID:
		m.ResetUserID()
		return nil
	case user.FieldMail:
		m.ResetMail()
		return nil
	case user.FieldBirthDate:
		m.ResetBirthDate()
		return nil
	case user.FieldLocation:
		m.ResetLocation()
		return nil
	case user.FieldLocationJa:
		m.ResetLocationJa()
		return nil
	case user.FieldSSOToken:
		m.ResetSSOToken()
		return nil
	case user.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case user.FieldSelected:
		m.ResetSelected()
		return nil
	case user.FieldCreated:
		m.ResetCreated()
		return nil
	case user.FieldModified:
		m.ResetModified()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
